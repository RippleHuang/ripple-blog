(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{650:function(t,a,s){"use strict";s.r(a);var e=s(4),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"html语义化理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html语义化理解"}},[t._v("#")]),t._v(" HTML语义化理解")]),t._v(" "),s("p",[t._v("什么：根据内容的结构(内容语义化)，选择合适的标签（代码语义化），便于开发者易读和易写代码同时让浏览器的爬虫和机器很好的解析")]),t._v(" "),s("p",[t._v("为什么：\n->1.在没有css的情况下，页面也能呈现出很好的效果\n->2.用户体验,例如title，alt，label的应用\n->3.有利于SEO，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和关键字权重\n->4方便团队开发和维护，减少差异性")]),t._v(" "),s("p",[t._v("怎么做：减少使用无语义的div与span，可以使用div或p时，尽量用p，p默认有上下间距，对兼容有利，不用纯样式标签b，font，u等，改用css设置\n需要强调的文本，可以用strong（不用b）和em（不用i），可以用css就不用这两个\n表单域要用fieldset标签包起来，并用legend标签说明表单的用途；\n每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来")]),t._v(" "),s("h2",{attrs:{id:"doctype作用，标准模式（严格）与兼容模式（混杂-怪异）区别，知道多少种doctype类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#doctype作用，标准模式（严格）与兼容模式（混杂-怪异）区别，知道多少种doctype类型"}},[t._v("#")]),t._v(" Doctype作用，标准模式（严格）与兼容模式（混杂/怪异）区别，知道多少种Doctype类型")]),t._v(" "),s("p",[t._v("作用：声明浏览器使用什么文档标准解析")]),t._v(" "),s("p",[t._v("区别：\n怪异模式，浏览器使用自己的怪异模式解析渲染页面\n1.怪癖模式中 ：width是元素的实际宽度；\n2.给span等行内元素设置wdith和height会生效；\n3.margin:0 auto会失效；\n4.图片的padding会失效；\n5.Table中的字体属性不能继承上层的设置；\n6.white-space:pre会失效；\n标准模式，浏览器使用W3C的标准解析渲染页面\n严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。\n在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。")]),t._v(" "),s("p",[t._v("DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。")]),t._v(" "),s("p",[t._v("三种：标准模式（standard mode）混杂模式（quirks mode）准标准模式（almost standard mode），标准与准标准基本一致\n标准模式可以通过strict.dtd或xhtml1-strict.dtd或HTML5直接"),s("code",[t._v("<!DOCTYPE html>")]),t._v("\n准标准模式可以使用过渡型（transitional）或框架集型（frameset）的文档类型来触发")]),t._v(" "),s("p",[t._v("使用 window.top.document.compatMode 可显示为什么模式")]),t._v(" "),s("h2",{attrs:{id:"html与xhtml-xml的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html与xhtml-xml的区别"}},[t._v("#")]),t._v(" HTML与XHTML,XML的区别")]),t._v(" "),s("p",[t._v("HTML：超文本标记语言，构成网页最基本的东西\nXML：可扩展标记语言 区别：HTML标签都是预定的，XML可以自己定义\nXHTML：可扩展超文本标记语言\n区别：XHTML 元素必须被正确地嵌套。\nXHTML 元素必须被关闭。\n标签名，属性名必须用小写字母。\n属性值必须加引号\n所有布尔值属性必须加属性值\nXHTML 文档必须拥有根元素。如body，head")]),t._v(" "),s("h2",{attrs:{id:"页面导入样式时，使用link和-import的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面导入样式时，使用link和-import的区别"}},[t._v("#")]),t._v(" 页面导入样式时，使用link和@import的区别")]),t._v(" "),s("p",[t._v("（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;")]),t._v(" "),s("h2",{attrs:{id:"html5有哪些新特性，移除了哪些，如何处理html5的浏览器兼容问题，如何区分html5与html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html5有哪些新特性，移除了哪些，如何处理html5的浏览器兼容问题，如何区分html5与html"}},[t._v("#")]),t._v(" HTML5有哪些新特性，移除了哪些，如何处理HTML5的浏览器兼容问题，如何区分HTML5与HTML")]),t._v(" "),s("p",[t._v("拖拽释放API\n画布 Canvas;\n地理 Geolocation;\n音频与视频 video 和 audio 元素;\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\nsessionStorage 的数据在浏览器关闭后自动删除;\n语义化更好的内容元素，比如 article、footer、header、nav、section;\n表单控件，calendar、date、time、email、url、search;\n新的技术webworker, websocket, Geolocation;")]),t._v(" "),s("p",[t._v("移除的元素：\n纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n对可用性产生负面影响的元素：frame，frameset，noframes；")]),t._v(" "),s("p",[t._v("兼容：使用成熟的框架、比如html5shim")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('\x3c!--[if lt IE 9]>\n<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"<\/script>\n<![endif]--\x3e')]),t._v("\n")])])]),s("p",[t._v("区分HTML与HTML5：DOCTYPE声明\\新增的结构元素\\功能元素")]),t._v(" "),s("h2",{attrs:{id:"iframe的优缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#iframe的优缺点"}},[t._v("#")]),t._v(" iframe的优缺点")]),t._v(" "),s("p",[t._v("优点：\n解决加载缓慢的第三方内容如图标和广告等的加载问题\nSecurity sandbox，安全沙箱\n并行加载脚本")]),t._v(" "),s("p",[t._v("缺点：\niframe会阻塞主页面的Onload事件；\n搜索引擎的检索程序无法解读这种页面，不利于SEO;\n内容为空也需要加载时间")]),t._v(" "),s("p",[t._v("使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n动态给iframe添加src属性值，这样可以绕开以上两个问题。")]),t._v(" "),s("h2",{attrs:{id:"img的title与alt"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#img的title与alt"}},[t._v("#")]),t._v(" img的title与alt")]),t._v(" "),s("p",[t._v("title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。\nalt是"),s("img"),t._v("的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。")]),t._v(" "),s("h2",{attrs:{id:"对前端界面工程师的理解，对前端开发工程师的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对前端界面工程师的理解，对前端开发工程师的理解"}},[t._v("#")]),t._v(" 对前端界面工程师的理解，对前端开发工程师的理解")]),t._v(" "),s("p",[t._v("前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。\n1、实现界面交互\n2、提升用户体验\n3、有了Node.js，前端可以实现服务端的一些事情\n前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，\n参与项目，快速高质量完成实现效果图，精确到1px；\n与团队成员，UI设计，产品经理的沟通；\n做好的页面结构，页面重构和用户体验；\n处理hack，兼容、写出优美的代码格式；\n针对服务器的优化、拥抱最新前端技术。")]),t._v(" "),s("h2",{attrs:{id:"seo优化需要考虑什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#seo优化需要考虑什么"}},[t._v("#")]),t._v(" SEO优化需要考虑什么")]),t._v(" "),s("p",[t._v("语义化html标签\n合理的title, description,keywords;\n重要的html代码放前面\n少用iframe, 搜索引擎不会抓取iframe中的内容\n图片加上alt")]),t._v(" "),s("h2",{attrs:{id:"网页内容需要多语言，要怎么做"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网页内容需要多语言，要怎么做"}},[t._v("#")]),t._v(" 网页内容需要多语言，要怎么做")]),t._v(" "),s("p",[t._v("采用统一编码utf-8模式，utf-8与Unicode区别，前者是使用最广的一种unicode的实现方式，unicode用于统一地区性文字编码，utf-8就是每次8个位传输数据，而后者是1次16个位")]),t._v(" "),s("h2",{attrs:{id:"html5为什么只需要写-doctype-html"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html5为什么只需要写-doctype-html"}},[t._v("#")]),t._v(" HTML5为什么只需要写"),s("code",[t._v("<!DOCTYPE HTML>")])]),t._v(" "),s("p",[t._v("HTML4.01基于SGML。所以需要对DTD进行引用，HTMl5反之，但是需要doctype来规范浏览器行为\nSGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的")]),t._v(" "),s("h2",{attrs:{id:"行内元素，块状元素，空-void-元素有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行内元素，块状元素，空-void-元素有哪些"}},[t._v("#")]),t._v(" 行内元素，块状元素，空(void)元素有哪些")]),t._v(" "),s("p",[t._v("首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。\n（1）行内元素有：a b span img input select strong（强调的语气）\n（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p\n（3）常见的空元素：\n"),s("code",[t._v("<br> <hr> <img> <input> <link> <meta>")]),t._v("\n鲜为人知的是：\n"),s("code",[t._v("<area> <base> <col> <command> <embed> <keygen> <param> <source> <track> <wbr>")])]),t._v(" "),s("h2",{attrs:{id:"浏览器内核的理解，常见的浏览器内核"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核的理解，常见的浏览器内核"}},[t._v("#")]),t._v(" 浏览器内核的理解，常见的浏览器内核")]),t._v(" "),s("p",[t._v("主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n（1）渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n（2）JS引擎则：解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。所以渲染引擎又称浏览器内核")]),t._v(" "),s("p",[t._v("Trident内核：IE，360，搜狗浏览器；\nGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\nPresto内核：Opera7及以上 [Opera内核原为：Presto，现为：Blink;]\nBlink内核：Opera，Chrome [ Chrome的：Blink（WebKit的分支）]；\nWebkit内核：Safari，Chrome(已改为Blink)\n移动端的浏览器内核主要说的是系统内置浏览器的内核。")]),t._v(" "),s("p",[t._v("Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。")]),t._v(" "),s("p",[t._v("iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的")]),t._v(" "),s("h2",{attrs:{id:"html5的离线存储怎么使用，工作原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html5的离线存储怎么使用，工作原理是什么"}},[t._v("#")]),t._v(" HTML5的离线存储怎么使用，工作原理是什么")]),t._v(" "),s("p",[t._v("在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n如何使用：\n1、页面头部像下面一样加入一个manifest的属性；\n"),s("code",[t._v('<html manifest="cache.manifest">')]),t._v("\n2、在cache.manifest文件的编写离线存储的资源；\nCACHE MANIFEST\n#v0.11\nCACHE:\njs/app.js\ncss/style.css\nNETWORK:\nresourse/logo.png\nFALLBACK:\n/ /offline.html")]),t._v(" "),s("p",[t._v("3、在离线状态时，操作window.applicationCache进行需求实现")]),t._v(" "),s("p",[t._v("离线缓存和浏览器缓存的区别")]),t._v(" "),s("p",[t._v("离线缓存允许我们在没网的时候通过读取离线文件进行站点的访问，而浏览器缓存即使浏览器又对资源文件的缓存也必须在有网的情况下读取缓存文件以提高文件加载速度，没网的时候依然显示网络断开的错误。")]),t._v(" "),s("p",[t._v("Service Worker ,PWA离线缓存")]),t._v(" "),s("h2",{attrs:{id:"浏览器是怎么对html5的离线存储资源进行管理和加载的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是怎么对html5的离线存储资源进行管理和加载的"}},[t._v("#")]),t._v(" 浏览器是怎么对HTML5的离线存储资源进行管理和加载的")]),t._v(" "),s("p",[t._v("在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。")]),t._v(" "),s("p",[t._v("离线的情况下，浏览器就直接使用离线存储的资源。")]),t._v(" "),s("h2",{attrs:{id:"cookie，sessionstorage，localstorage的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cookie，sessionstorage，localstorage的区别"}},[t._v("#")]),t._v(" cookie，sessionStorage，localStorage的区别")]),t._v(" "),s("p",[t._v("cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n存储大小：\ncookie数据大小不能超过4k。\nsessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M-10M。\n有期时间：\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\nsessionStorage 数据在当前浏览器窗口关闭后自动删除。\ncookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭")]),t._v(" "),s("h2",{attrs:{id:"label的作用，是怎么用的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#label的作用，是怎么用的"}},[t._v("#")]),t._v(" Label的作用，是怎么用的")]),t._v(" "),s("div",{staticClass:"language-html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("label")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Number:"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("label")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v('\n <input type=“text“name="Name" id="Name"/>\n '),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("label")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("Date:"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("text"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("name")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("B"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("label")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),s("p",[t._v("label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验")]),t._v(" "),s("h2",{attrs:{id:"如何实现浏览器内多个标签页之间的通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现浏览器内多个标签页之间的通信"}},[t._v("#")]),t._v(" 如何实现浏览器内多个标签页之间的通信")]),t._v(" "),s("p",[t._v("WebSocket、SharedWorker；\n也可以调用localstorge、cookies等本地存储方式；\nlocalstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n我们通过监听事件，控制它的值来进行页面信息通信；\n注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；")]),t._v(" "),s("h2",{attrs:{id:"如何在页面上实现圆形可点击区域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何在页面上实现圆形可点击区域"}},[t._v("#")]),t._v(" 如何在页面上实现圆形可点击区域")]),t._v(" "),s("p",[t._v("1、map+area或者svg\n2、border-radius\n3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等")]),t._v(" "),s("h2",{attrs:{id:"title与h1，b与strong，i与em的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#title与h1，b与strong，i与em的区别"}},[t._v("#")]),t._v(" title与h1，b与strong，i与em的区别")]),t._v(" "),s("p",[t._v("title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；\nstrong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时："),s("strong",[t._v("会重读，而"),s("B",[t._v("是展示强调内容。\ni内容展示为斜体，em表示强调的文本；\nPhysical Style Elements -- 自然样式标签\nb, i, u, s, pre\nSemantic Style Elements -- 语义样式标签\nstrong, em, ins, del, code\n应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。")])],1)]),t._v(" "),s("h2",{attrs:{id:"使用data-属性的好处是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用data-属性的好处是什么"}},[t._v("#")]),t._v(" 使用data-属性的好处是什么")]),t._v(" "),s("p",[t._v("自定义属性在dataset对象中统一管理，遍历很方便，不至于零零散散;\n可以利用这一点在生成DOM结构时把数据储存在自定义属性中,通过一系列交互操作,可以再获得这些数据,而不再用ajax去后台取得数据。")]),t._v(" "),s("h2",{attrs:{id:"把html5看做一个开放平台，他的构建模块有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#把html5看做一个开放平台，他的构建模块有哪些"}},[t._v("#")]),t._v(" 把HTML5看做一个开放平台，他的构建模块有哪些")]),t._v(" "),s("p",[t._v("标签及属性 地理位置 画布 视频 音频 拖放 微数据 应用缓存 Web存储 web workers 服务器发送事件")]),t._v(" "),s("h2",{attrs:{id:"script-script-async-和-script-defer-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#script-script-async-和-script-defer-的区别"}},[t._v("#")]),t._v(" "),s("code",[t._v("<script>")]),t._v(","),s("code",[t._v("<script async>")]),t._v("和"),s("code",[t._v("<script defer>")]),t._v(" 的区别")]),t._v(" "),s("p",[t._v("1.首先"),s("code",[t._v("<script async>")]),t._v("和"),s("code",[t._v("<script defer>")]),t._v("都是异步加载js文件；\n2.区别是：async在加载完之后自动执行；defer:在所有元素解析完之后；")]),t._v(" "),s("h2",{attrs:{id:"为什么推荐css-link-在head之前，js-script-在-body-之前"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么推荐css-link-在head之前，js-script-在-body-之前"}},[t._v("#")]),t._v(" 为什么推荐css"),s("code",[t._v("<link>")]),t._v("在head之前，js"),s("code",[t._v("<script>")]),t._v("在"),s("code",[t._v("</body>")]),t._v("之前")]),t._v(" "),s("p",[t._v("作用：当页面渲染完成再去执行"),s("code",[t._v("< script>")]),t._v("，防止页面阻塞。\n例外：希望DOM还没加载必须需要先加载的js会放置在")]),s("head",[t._v("中,有些加了defer、async的"),s("script")])])}),[],!1,null,null,null);a.default=n.exports}}]);