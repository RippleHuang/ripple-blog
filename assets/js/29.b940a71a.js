(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{644:function(v,_,t){"use strict";t.r(_);var e=t(4),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",[v._v("CSS 页面布局")])]),v._v(" "),t("h2",{attrs:{id:"常见五大布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见五大布局"}},[v._v("#")]),v._v(" 常见五大布局")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://p3.pstatp.com/large/pgc-image/556d54baf46248108b1dea1dc6fae4c5",alt:"CSS常见的五大布局"}})]),v._v(" "),t("h3",{attrs:{id:"单列布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单列布局"}},[v._v("#")]),v._v(" 单列布局")]),v._v(" "),t("p",[v._v("常见的单列布局有两种：")]),v._v(" "),t("ul",[t("li",[v._v("header,content 和 footer 等宽的单列布局")]),v._v(" "),t("li",[v._v("header 与 footer 等宽,content 略窄的单列布局")])]),v._v(" "),t("ol",[t("li",[v._v("如何实现")])]),v._v(" "),t("p",[v._v("对于第一种，先通过对 header,content,footer 统一设置 "),t("code",[v._v("width：1000px")]),v._v(";或者 "),t("code",[v._v("max-width：1000px")]),v._v("(这两者的区别是当屏幕小于 "),t("code",[v._v("1000px")]),v._v(" 时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置 "),t("code",[v._v("margin:auto")]),v._v(" 实现居中即可得到。")]),v._v(" "),t("p",[v._v("对于第二种，header、footer 的内容宽度不设置，块级元素充满整个屏幕，但 header、content 和 footer 的内容区设置同一个 width，并通过 "),t("code",[v._v("margin:auto")]),v._v(" 实现居中。")]),v._v(" "),t("h3",{attrs:{id:"两列自适应布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两列自适应布局"}},[v._v("#")]),v._v(" 两列自适应布局")]),v._v(" "),t("p",[v._v("两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式")]),v._v(" "),t("ol",[t("li",[t("p",[t("code",[v._v("float")]),v._v(" +"),t("code",[v._v("overflow:hidden")])]),v._v(" "),t("p",[v._v("如果是普通的两列布局，浮动+普通元素的 margin 便可以实现，但如果是自适应的两列布局，利用"),t("code",[v._v("float+overflow:hidden")]),v._v("便可以实现，这种办法主要通过 overflow 触发 BFC ,而 BFC 不会重叠浮动元素。由于设置 "),t("code",[v._v("overflow:hidden")]),v._v(" 并不会触发 IE6 -浏览器的 "),t("code",[v._v("haslayout")]),v._v(" 属性，所以需要设置 "),t("code",[v._v("zoom:1")]),v._v(" 来兼容 IE6-浏览器")]),v._v(" "),t("p",[v._v("注意点:如果侧边栏在右边时，注意渲染顺序。即在 HTML 中，先写侧边栏后写主内容")])]),v._v(" "),t("li",[t("p",[v._v("Flexbox 布局")]),v._v(" "),t("p",[v._v("Flexbox 布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。")])]),v._v(" "),t("li",[t("p",[v._v("Grid 布局")]),v._v(" "),t("p",[v._v("Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。")])])]),v._v(" "),t("h3",{attrs:{id:"三栏布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三栏布局"}},[v._v("#")]),v._v(" 三栏布局")]),v._v(" "),t("p",[v._v("特征：中间列自适应宽度，旁边两侧固定宽度，实现三栏布局有多种方式：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("浮动布局")]),v._v(" "),t("p",[v._v("这种布局方式，dom 结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。 浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。")])]),v._v(" "),t("li",[t("p",[v._v("绝对定位布局")]),v._v(" "),t("p",[v._v("绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。")])]),v._v(" "),t("li",[t("p",[v._v("flexbox 布局")]),v._v(" "),t("p",[v._v("flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。")])]),v._v(" "),t("li",[t("p",[v._v("表格布局")]),v._v(" "),t("p",[v._v("表格布局的兼容性很好，在 flex 布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。表格布局也是有缺陷:① 无法设置栏边距；② 对 seo 不友好；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。")])]),v._v(" "),t("li",[t("p",[v._v("网格布局")]),v._v(" "),t("p",[v._v("CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。")]),v._v(" "),t("p",[v._v("但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。")])]),v._v(" "),t("li",[t("p",[v._v("圣杯布局")]),v._v(" "),t("p",[v._v("比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载。")]),v._v(" "),t("p",[v._v("② 实现步骤")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置 center 的宽度为 100%(实现中间列内容自适应)，此时，left 和 right 部分会跳到下一行")])]),v._v(" "),t("li",[t("p",[v._v("通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行")])]),v._v(" "),t("li",[t("p",[v._v("通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙。")])]),v._v(" "),t("li",[t("p",[v._v("通过设置相对定位，让 left 和 right 部分移动到两边。")])])]),v._v(" "),t("p",[v._v("③ 缺点")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行")])]),v._v(" "),t("li",[t("p",[v._v("如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正 padding+负 margin 可解决，下文会介绍)")])])])]),v._v(" "),t("li",[t("p",[v._v("双飞翼布局")]),v._v(" "),t("p",[v._v("① 特点")]),v._v(" "),t("p",[v._v("同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。")]),v._v(" "),t("p",[v._v("② 实现步骤(前两步与圣杯布局一样)")]),v._v(" "),t("ul",[t("li",[v._v("三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行；")]),v._v(" "),t("li",[v._v("通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行；")]),v._v(" "),t("li",[v._v("center 部分增加一个内层 div，并设 margin: 0 200px；")])]),v._v(" "),t("p",[v._v("③ 缺点")]),v._v(" "),t("p",[v._v("多加一层 dom 树节点，增加渲染树生成的计算量。")]),v._v(" "),t("p",[v._v("④ 圣杯布局和双飞翼布局实现方式对比:")]),v._v(" "),t("ul",[t("li",[v._v("两种布局方式都是把主列放在文档流最前面，使主列优先加载。")]),v._v(" "),t("li",[v._v("两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。")]),v._v(" "),t("li",[v._v("两种布局方式的不同之处在于如何处理中间主列的位置： 圣杯布局是利用父容器的左、右内边距+两个从列相对定位; 双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整")])])])]),v._v(" "),t("h3",{attrs:{id:"等高布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等高布局"}},[v._v("#")]),v._v(" 等高布局")]),v._v(" "),t("p",[v._v("等高布局是指子元素在父元素中高度相等的布局方式。等高布局的实现包括伪等高和真等高,伪等高只是看上去等高而已,真等高是实实在在的等高。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("利用背景图片")]),v._v(" "),t("p",[v._v("这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行 Y 轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的 css 样式就可以轻松实现,但此方法不适合流体布局等高列的布局。")])]),v._v(" "),t("li",[t("p",[v._v("利用正 padding+负 margin")]),v._v(" "),t("p",[v._v("我们通过等布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器")])]),v._v(" "),t("li",[t("p",[v._v("模仿表格布局")]),v._v(" "),t("p",[v._v("这是一种非常简单，易于实现的方法。不过兼容性不好，在 ie6-7 无法正常运行。")])]),v._v(" "),t("li",[t("p",[v._v("使用边框和定位")]),v._v(" "),t("p",[v._v("这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。")])])]),v._v(" "),t("h3",{attrs:{id:"粘连布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#粘连布局"}},[v._v("#")]),v._v(" 粘连布局")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("特点")]),v._v(" "),t("ul",[t("li",[v._v("有一块内容"),t("code",[v._v("<main>")]),v._v("，当"),t("code",[v._v("<main>")]),v._v("的高康足够长的时候，紧跟在"),t("code",[v._v("<main>")]),v._v("后面的元素"),t("code",[v._v("<footer>")]),v._v("会跟在"),t("code",[v._v("<main>")]),v._v("元素的后面。")]),v._v(" "),t("li",[v._v("当"),t("code",[v._v("<main>")]),v._v("元素比较短的时候(比如小于屏幕的高度),我们期望这个"),t("code",[v._v("<footer>")]),v._v("元素能够“粘连”在屏幕的底部")])]),v._v(" "),t("p",[t("img",{attrs:{src:"http://p99.pstatp.com/large/pgc-image/44e8e012b8314ad78878fe4758b23b0c",alt:"CSS常见的五大布局"}})])]),v._v(" "),t("li",[t("p",[v._v("实现步骤")]),v._v(" "),t("p",[v._v("(1)footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系")]),v._v(" "),t("p",[v._v("(2)wrap 区域的高度通过设置 min-height，变为视口高度")]),v._v(" "),t("p",[v._v("(3)footer 要使用 margin 为负来确定自己的位置")]),v._v(" "),t("p",[v._v("(4)在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[v._v(" 1 table 布局\n 2 flex 布局\n     2.1 盒模型\n     2.2 display / poistion\n     2.3 flexbox 布局\n 3 float 布局\n     3.1 高度塌陷\n     3.2 两栏布局\n     3.3 三栏布局\n 4 响应式布局\n     4.1 meta 标签\n     4.2 使用 rem\n     4.3 media query\n 5 总结\n")])])])])]),v._v(" "),t("h2",{attrs:{id:"自适应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自适应"}},[v._v("#")]),v._v(" 自适应")]),v._v(" "),t("p",[v._v("单位不要用 px，可以使用 rem，vh，vw等")]),v._v(" "),t("p",[v._v("图标相当于字体，可以用处理字体的方式来处理图标")]),v._v(" "),t("p",[v._v("flex 属性相当于 bootstranp 的栅格，必须父元素要 flexd")]),v._v(" "),t("h2",{attrs:{id:"字体问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字体问题"}},[v._v("#")]),v._v(" 字体问题")]),v._v(" "),t("p",[v._v("谷歌浏览器 font-size 小于 12px 时，字体不在变小")]),v._v(" "),t("p",[v._v("手机上浏览器")]),v._v(" "),t("p",[v._v("浏览器最小字号限制是 6px（例如自带浏览器、UC）\n如果是 8px（例如微信、QQ、百度）\n如果是 12px（例如 chrome 和三星某些机器默认浏览器）")])])}),[],!1,null,null,null);_.default=a.exports}}]);